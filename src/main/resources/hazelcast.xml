<?xml version="1.0" encoding="UTF-8"?>
<!--
  ~ Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~ http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<!--
  This is a full example hazelcast.xml that includes all the
  configuration elements and attributes of a Hazelcast member.

  To use this, rename it to hazelcast.xml and place it in
  the directory where you start your Hazelcast member.

  To learn how to configure Hazelcast, please see the schema at
  https://hazelcast.com/schema/config/hazelcast-config-4.2.xsd
  or the Reference Manual at https://hazelcast.org/documentation/
-->

<!--suppress XmlDefaultAttributeValue -->
<hazelcast xmlns="http://www.hazelcast.com/schema/config"
           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
           xsi:schemaLocation="http://www.hazelcast.com/schema/config
           http://www.hazelcast.com/schema/config/hazelcast-config-4.2.xsd">
    

    <!--
        Specifies the cluster name. It allows creating separate sub-clusters with different names.
        The name is also referenced in the WAN Replication configuration.
    -->
    <cluster-name>my-cluster</cluster-name>
   
    <!--
        When Hazelcast instances are created, they are put in a global registry with their creation names.
        <instance-name> elements gives you the ability to get a specific Hazelcast instance from this registry
        by giving the instance's name.
    -->
    <instance-name>hzInstance1</instance-name>
    <!--
        ===== HAZELCAST MANAGEMENT CENTER CONFIGURATION =====

        The element <management-center> has the following optional attributes:
        * scripting-enabled:
        Set to true to allow scripting on the member, false to disallow.
        Default value is false.

        Hazelcast's Open Source edition provides the Management Center with monitoring at most 3 members
        in your cluster.
    -->
    <management-center scripting-enabled="false"/>
    <!--
        The <properties> element lets you add properties to some of the Hazelcast elements used to configure some of
        the Hazelcast modules.
        You can define the name and value of these properties using the sub-element <property>.
        You can use <properties> for the following Hazelcast configuration elements:
        * <discovery-strategy>
        * <map-store>
        * <queue-store>
        * <wan-replication>
        * <service>
        * <login-module>
        * <security-object>

    -->
    <properties>
        <property name="your-property">Value of the property</property>
    </properties>

   <!--
        ===== HAZELCAST NETWORK CONFIGURATION =====

        The configuration to build your Hazelcast's network includes configuration for port, interface, discovery
        mechanism, encryption, etc. The configuration element's name is <network>.
        It has the following sub-elements:
        * <public address>:
        This optional element overrides the public address of a member. It is useful when
        you have a private cloud. Normally, a member selects its socket address as its public address. But behind a NAT,
        two members may not be able to see/access each other. In this case, you can set their public addresses to their
        defined addresses on NAT. The value should be given in the format "host IP address:port number".
        * <port>:
        Specifies the ports that Hazelcast will use to communicate between cluster members. It is optional and
        its default value is 5701. It has the following attributes:
        - port-count:
            By default, Hazelcast will try 100 ports to bind (i.e. the ports between 5701 and 5801). You can
            change the port count in such cases as having large instances on a single machine or you are
            willing to have only a few ports assigned. port-count is optional and its default value is 100.
        - auto-increment:
            By default, Hazelcast tries to find a port by automatically incrementing the port numbers. If you
            don't want this (for example, you want to use a specific port), set auto-increment to false. If it is
            set to false, the port-count attribute is ignored. auto-increment is optional and its default value is true.
            Examples:
            The example below looks for ports between 5701 and 5721, incrementing the ports starting from 5701.
            <port port-count="20">5701</port>
            The example below forces Hazelcast to use only the port 5701.
            <port auto-increment="false">5701</port>
        * <outbound-ports>:
        By default, Hazelcast lets the system pick up an ephemeral port during socket bind operation. But security
        policies/firewalls may require you to restrict outbound ports to be used by Hazelcast-enabled applications.
        You can specify these ports using <ports> under the element <outbound-ports>. You can give a single
        port number, comma separated multiple ports or port ranges. See the example below.
        <outbound-ports>
            <ports>33000-35000</ports>
            <ports>37000,37001,37002,37003</ports>
            <ports>38000,38500-38600</ports>
        </outbound-ports>
        * <reuse-address>:
        If you set this to true, Hazelcast will use the same port when you restart a member right after you
        shut it down. It is optional and its default value is false.
        * <join>:
        This configuration lets you choose a discovery mechanism that Hazelcast will use to form a cluster.
        Hazelcast can find members by multicast, TCP/IP lists and by various discovery mechanisms provided by different cloud APIs.
        The following are the elements of <join>:
        - <multicast>:
            Set its "enabled" attribute to true for discovery by multicast. It has another attribute
            ("loopbackModeEnabled") which enables or disables the loopback mode in the multicast discovery
            mechanism.
            It has the following sub-elements to fine tune the multicast discovery.
            - <multicast-group>:
                Specifies the multicast group IP address when you want to create clusters within
                the same network. Its default value is 224.2.2.3.
            - <multicast-port>:
                Specifies the multicast socket port that the Hazelcast member listens to and
                sends discovery messages through. Its default value is 54327.
            - <multicast-time-to-live>:
                Time-to-live value for multicast packets sent out to control the scope of multicasts.
            - <multicast-timeout-seconds>:
                Only when the members are starting up, this timeout (in seconds) specifies the
                period during which a member waits for a multicast response from another node.
                For example, if you set it as 60 seconds, each node will wait for 60 seconds until a
                leader node is selected. Its default value is 2 seconds.
            - <trusted-interfaces>:
                Includes IP addresses of trusted members. When a node wants to join to the cluster,
                its join request will be rejected if it is not a trusted member.
                You can give an IP addresses range using the wildcard (*) on the last digit of
                IP address (e.g. 192.168.1.* or 192.168.1.100-110).
        - <tcp-ip>:
            It has the following attributes.
            - "enabled":
                Specifies whether the TCP/IP discovery is enabled or not. Default value is false.
            - "connection-timeout-seconds":
                The maximum amount of time Hazelcast is going to try to connect to a well known member
                before giving up. Setting it to a too low value could mean that a member is not able
                to connect to a cluster. Setting it to a too high value means that member startup could
                slow down because of longer timeouts (e.g. when a well known member is not up). Increasing
                this value is recommended if you have many IPs listed and the members cannot properly
                build up the cluster. Its default value is 5.

            It has the following sub-elements.
            - <required-member>:
                IP address of the required member. Cluster will only be formed if the member with this
                IP address is found.
            - <member>:
                IP address(es) of one or more well known members. Once members are connected to these
                well known ones, all member addresses will be communicated with each other. You can
                also give comma separated IP addresses using the <members> element or list the members
                with the <member> element under <member-list>.
            - <members>:
                Comma separated IP addresses of one or more well known members.
            - <member-list>:
                IP address(es) of one or more well known members listed with the <member> element.
            - <interface>:
                IP address(es) of one or more well known members.
        - <aws>:
            Set its "enabled" attribute to true for discovery within Amazon EC2.
            Please refer to https://github.com/hazelcast/hazelcast-aws/#configuration for the configuration details.
        - <gcp>:
            Set its "enabled" attribute to true for discovery within the Google Cloud Platform.
            Please refer to https://github.com/hazelcast/hazelcast-gcp/#configuration for the configuration details.
        - <azure>:
            Set its "enabled" attribute to true for discovery within Microsoft Azure.
            Please refer to https://github.com/hazelcast/hazelcast-azure/#configuring-at-hazelcast-side for
            the configuration details.
        - <kubernetes>:
            Set its "enabled" attribute to true for discovery in the Kubernetes environment.
            Please refer to https://github.com/hazelcast/hazelcast-kubernetes#hazelcast-configuration for
            the configuration details.
        - <eureka>:
            Set its "enabled" attribute to true for discovery with using Eureka Service Registry.
            Please refer to https://github.com/hazelcast/hazelcast-eureka#hazelcast-configuration for
            the configuration details.
        - <discovery-strategies>:
            Set its "enabled" attribute to true for discovery in various cloud infrastructures. You also need to set the
            value of "hazelcast.discovery.enabled" property to true. See the description of the <properties> element
            to learn how to do this.
            You can define multiple discovery strategies using the <discovery-strategy> sub-element and its
            properties. Please refer to
            http://docs.hazelcast.org/docs/latest/manual/html-single/index.html#discovering-cluster-members
            to see the properties you can use.
            The following is an example for EC2 cloud.
            <discovery-strategies>
                <discovery-strategy class="com.hazelcast.jclouds.JCloudsDiscoveryStrategy" enabled="true">
                <properties>
                    <property name="provider">aws-ec2</property>
                    <property name="identity">AWS_IDENTITY</property>
                    <property name="credential">AWS_CREDENTIAL</property>
                </properties>
                </discovery-strategy>
            </discovery-strategies>
        * <interfaces>:
        Specifies which network interfaces Hazelcast should use. You need to set its "enabled" attribute
        to true to be able to use your defined interfaces. You can define multiple interfaces
        using its <interface> sub-element. By default, it is disabled.
                
        * <member-address-provider>:
        IMPORTANT
        This configuration is not intended to provide addresses of other cluster members with
        which the Hazelcast instance will form a cluster. This is an SPI for advanced use in
        cases where the DefaultAddressPicker does not pick suitable addresses to bind to
        and publish to other cluster members. For instance, this could allow easier
        deployment in some cases when running on Docker, AWS or other cloud environments.
        That said, if you are just starting with Hazelcast, you will probably want to
        set the member addresses by using the tcp-ip or multicast configuration
        or adding a discovery strategy.
        Member address provider allows to plug in own strategy to customize:
           1. What address Hazelcast will bind to
           2. What address Hazelcast will advertise to other members on which they can bind to
        In most environments you don't need to customize this and the default strategy will work just
        fine. However in some cloud environments the default strategy does not make the right choice and the
        member address provider delegates the process of address picking to external code. It has one optional attribute:
        * enabled:
        Specifies whether the member address provider SPI is enabled or not. Its default value is false.
        It has the following sub-elements:
            - <class-name>:
                The name of the class implementing the com.hazelcast.spi.MemberAddressProvider interface.
            - <properties>:
                The properties that will be provided when constructing the provided MemberAddressProvider. Hazelcast will
                first try instantiating the provided class by invoking a constructor accepting a single
                java.util.Properties instance. In the case where there is no such constructor and there are also
                no properties defined by this configuration, Hazelcast will exceptionally try to use the no-arg
                constructor.
        * <failure-detector>:
        A failure detector is responsible to determine if a member in the cluster is unreachable or crashed.
        Please refer to https://docs.hazelcast.org/docs/latest/manual/html-single/index.html#failure-detector-configuration
        for the failure detectors implemented by Hazelcast.

        This element has the following sub-element:
        * <icmp>:
        ICMP can be used in addition to the other detectors. It operates at layer 3 and detects network
        and hardware issues more quickly.

        It has the following sub-elements:
        * <timeout-milliseconds>:
            Timeout in Milliseconds before declaring a failed ping.
        * <fail-fast-on-startup>:
            Cluster Member will fail to start if it is unable to action an ICMP ping command when ICMP is enabled.
            Failure is usually due to OS level restrictions.
        * <interval-milliseconds>:
            Time in milliseconds between each ICMP ping.
        * <max-attempts>:
            Maximum number of consecutive failed attempts before declaring a member suspect.
        * <parallel-mode>:
            Run ICMP detection in parallel with the Heartbeat failure detector.
        * <ttl>:
            Maximum number of times the IP Datagram (ping) can be forwarded, in most cases
            all Hazelcast cluster members would be within one network switch/router therefore
            default of 0 is usually sufficient.
    -->
    <network>
        <port auto-increment="true" port-count="100">5701</port>
        <outbound-ports>
            <ports>34500</ports>
        </outbound-ports>
        <reuse-address>true</reuse-address>
        <join>
            <auto-detection enabled="false"/>
            <multicast enabled="false">
                <multicast-group>224.2.2.3</multicast-group>
                <multicast-port>54327</multicast-port>
            </multicast>
            <tcp-ip enabled="true">
                <member-list>
                    
                </member-list>
            </tcp-ip>            
        </join>
        <interfaces enabled="false">
            <interface>10.10.1.*</interface>
        </interfaces>
        
        <!--
        ===== HAZELCAST REST API CONFIGURATION =====

        Configures Hazelcast HTTP REST API.
        The <rest-api/> element has a global enabled switch, which controls the entrypoint to HTTP REST API. If it's disabled
        then no text protocol is available.
        Once the global switch is enabled there is an optional second level of control - REST endpoint groups. They are configured
        by element <endpoint-group/>.
        Groups and their defaults:
        * CLUSTER_READ - enabled
          Group of operations for retrieving cluster state and its version.
        * CLUSTER_WRITE - disabled
          Operations which changes cluster or node state or their configurations.
        * HEALTH_CHECK - disabled
          Group of endpoints for HTTP health checking.
        * HOT_RESTART - disabled
          Group of HTTP REST APIs related to Hot Restart feature.
        * WAN - disabled
          Group of HTTP REST APIs related to WAN Replication feature.
        * DATA - disabled
          Group of HTTP REST APIs for data manipulation in the cluster (e.g. IMap and IQueue operations).
        -->
        <rest-api enabled="false">
            <endpoint-group name="CLUSTER_READ" enabled="true"/>
            <endpoint-group name="CLUSTER_WRITE" enabled="false"/>
            <endpoint-group name="HEALTH_CHECK" enabled="false"/>
            <endpoint-group name="HOT_RESTART" enabled="false"/>
            <endpoint-group name="WAN" enabled="false"/>
            <endpoint-group name="DATA" enabled="false"/>
        </rest-api>

        <!--
        ===== HAZELCAST MEMCACHE PROTOCOL CONFIGURATION =====

        Allows to configure Memcache text protocol support in Hazelcast.
        -->
        <memcache-protocol enabled="false"/>
    </network>
    <!--
        ===== PARTITION GROUPING CONFIGURATION =====

        Configuration element's name is <partition-group>. You can enable it and specify the type using
        the "enabled" and "group-type" attributes. For CUSTOM type, you can define groups using its
        <member-group> and <interface> sub-elements. You can group the members with one of the following types:
        * HOST_AWARE:
        Members sharing the same network interface are grouped together. All members on the same host will be a
        single partition group.
        * CUSTOM:
        You can add different and multiple members to a group.
        * PER_MEMBER:
        Each member is a group of its own and primary/backup partitions are distributed
        randomly (not on the same physical member).
        * ZONE_AWARE:
        Backups are created in the other zones. Each zone will be accepted as one partition group.
        It can be used when you make use of Hazelcast's jclouds or Azure discovery service plugins.
        * SPI:
        You can provide your own partition group implementation using the SPI grouping type. Please see
        Partition Group Configuration section in Hazelcast Reference Manual.
    -->
    <partition-group enabled="true" group-type="CUSTOM">
        <member-group>
            <interface>10.10.0.*</interface>
            <interface>10.10.3.*</interface>
            <interface>10.10.5.*</interface>
        </member-group>
        <member-group>
            <interface>10.10.10.10-100</interface>
            <interface>10.10.1.*</interface>
            <interface>10.10.2.*</interface>
        </member-group>
    </partition-group>


    <!--
        ===== HAZELCAST EXECUTOR SERVICE CONFIGURATION =====

        Configuration element's name is <executor-service>. It has the optional attribute "name" with which you
        can specify the name of your executor service. Its default value is "default".
        It has the following sub-elements:
        * <statistics-enabled>:
        When you enable it, you can retrieve executor service statistics such as pending operations count,
        started operations count, completed operations count, and cancelled operations count. Its default
        value is true.
        * <pool-size>:
        The number of executor threads per member for the executor. Its default value is 8.
        * <queue-capacity>:
        Task queue capacity of the executor. Its default value is 0, meaning Integer.MAX_VALUE.
        * <split-brain-protection-ref>:
        Adds the Split Brain Protection for this data-structure which you configure using the <split-brain-protection>
        element. You should set the <split-brain-protection-ref>'s value as the <split-brain-protection>'s name.
    -->
    <executor-service name="default">
        <statistics-enabled>true</statistics-enabled>
        <pool-size>16</pool-size>
        <queue-capacity>0</queue-capacity>
    </executor-service>

    <!--
        ===== HAZELCAST DURABLE EXECUTOR SERVICE CONFIGURATION =====

        Configuration element's name is <durable-executor-service>. It has the optional attribute "name" with which you
        can specify the name of your durable executor service. Its default value is "default".
        It has the following sub-elements:
        * <pool-size>:
        The number of executor threads per member for the executor. Its default value is 16.
        * <durability>:
            Durability of the executor. The default value is 1.
        * <capacity>:
        Capacity of the executor task per partition. The default value is 100.
        * <split-brain-protection-ref>:
        Adds the Split Brain Protection for this data-structure which you configure using the <split-brain-protection>
        element. You should set the <split-brain-protection-ref>'s value as the <split-brain-protection>'s name.
    -->
    <durable-executor-service name="default">
        <pool-size>16</pool-size>
        <durability>1</durability>
        <capacity>100</capacity>
        <split-brain-protection-ref>splitBrainProtectionRuleWithThreeNodes</split-brain-protection-ref>
    </durable-executor-service>

    <!--
        ===== HAZELCAST SCHEDULED EXECUTOR SERVICE CONFIGURATION =====

        Configuration element's name is <scheduled-executor-service>. It has the optional attribute "name" with which you
        can specify the name of your scheduled executor service. Its default value is "default".
        It has the following sub-elements:
        * <pool-size>:
            The number of executor threads per member for the executor. Its default value is 16.
        * <durability>:
            Durability of the scheduled executor. The default value is 1.
        * <capacity>:
            Capacity of the scheduled executor. The default value is 100.
            This is the maximum number of tasks for a given scheduled executor on a particular partition.
        * <capacity-policy>:
            The active policy for the capacity setting. Default is PER_NODE
            Available options (PER_PARTITION, PER_NODE)
        * <split-brain-protection-ref>:
            Adds the Split Brain Protection for this data-structure which you configure using the <split-brain-protection>
            element. You should set the <split-brain-protection-ref>'s value as the <split-brain-protection>'s name.
        * <merge-policy>:
            The default policy is PutIfAbsentMergePolicy with a batch size of 100.
            This is the policy used when merging entries from sub-clusters (after split-brain recovery).
    -->
    <scheduled-executor-service name="default">
        <pool-size>16</pool-size>
        <durability>1</durability>
        <capacity>100</capacity>
        <capacity-policy>PER_NODE</capacity-policy>
        <split-brain-protection-ref>splitBrainProtectionRuleWithThreeNodes</split-brain-protection-ref>
        <merge-policy batch-size="100">PutIfAbsentMergePolicy</merge-policy>
    </scheduled-executor-service>

    <!--
    ===== HAZELCAST CARDINALITY ESTIMATOR SERVICE CONFIGURATION =====

    Configuration element's name is <cardinality-estimator>. It has the optional attribute "name" with which you
    can specify the name of your estimator. Its default value is "default".
    It has the following sub-elements:
    * <backup-count>:
       Number of synchronous backups. For example, if 1 is set as the backup-count,
       then the cardinality estimation will be copied to one other JVM for
       fail-safety. Valid numbers are 0 (no backup), 1, 2 ... 6.
    * <async-backup-count>:
        Number of asynchronous backups. For example, if 1 is set as the backup-count,
       then the cardinality estimation will be copied to one other JVM for
       fail-safety. Valid numbers are 0 (no backup), 1, 2 ... 6.
    * <split-brain-protection-ref>:
       Adds the Split Brain Protection for this data-structure which you configure using the <split-brain-protection>
       element. You should set the <split-brain-protection-ref>'s value as the <split-brain-protection>'s name.
    * <merge-policy>:
        The default policy is `com.hazelcast.spi.merge.HyperLogLogMergePolicy` with a batch size of 100.
        This is the policy used when merging estimators from sub-clusters (after split-brain recovery).
    -->
    <cardinality-estimator name="default">
        <backup-count>1</backup-count>
        <async-backup-count>0</async-backup-count>
        <split-brain-protection-ref>splitBrainProtectionRuleWithThreeNodes</split-brain-protection-ref>
        <merge-policy batch-size="102">PutIfAbsentMergePolicy</merge-policy>
    </cardinality-estimator>

    <!--
        ===== HAZELCAST QUEUE CONFIGURATION =====

        Configuration element's name is "queue".
        It has following optional attributes:
        * "name"
        with which you can specify the name of your queue. Its default value is "default".
        It has the following elements:
        * <statistics-enabled>:
        When you enable it, you can retrieve queue statistics. Its default value is true.
        * <max-size>:
        Maximum size of the queue. When a JVM's local queue size reaches the maximum, all put/offer operations
        will be blocked until the queue size of the JVM goes below this maximum. Its default value is 0,
        meaning Integer.MAX_VALUE.
        * <backup-count>:
        Number of synchronous backups. Queue is a non-partitioned data structure, so all entries of a Queue
        resides in one partition. When this parameter is '1', it means there will be 1 backup of that Queue in
        another member in the cluster. When it is '2', 2 members will have the backup. 0 means there will be no
        backups. Its default value is 1.
        * <async-backup-count>:
        Number of asynchronous backups. Its default value is 0.
        * <empty-queue-ttl>:
        Used to purge unused or empty queues. If you define a value (time in seconds) for this element, then
        your queue will be destroyed if it stays empty or unused for that time.
        * <item-listeners>:
        Adds listeners (listener classes) for the queue items using its sub-element <item-listener>. You can
        also set its attribute "include-value" to true if you want the item event to contain the item values,
        and you can set its attribute "local" to true if you want to listen to the items on the local member.
        * <queue-store>:
        Includes configuration elements and attributes for your queue store implementation. When you want to
        load/store the distributed queue items from/to a persistent datastore, first implement Hazelcast's
        QueueStore interface and then configure it using this element. It includes your implemented class name
        and the following property configurations:
        - binary:
            If you do not reach the queue store from an external application, you might prefer to insert the items
            in binary form. To do so, set this property to true and skip the deserialization step, which is a
            performance optimization. Its default value is false.
        - memory-limit:
            Number of items after which Hazelcast will store items only to datastore. For example,
            if the memory limit is 1000, then the 1001st item will be put only to datastore.
            This feature is useful when you want to avoid out-of-memory conditions. If you want to
            always use memory, you can set it to Integer.MAX_VALUE. Its default value is 1000.
        - bulk-load:
            Size of the bulks loaded from QueueStore when the queue is initialized. Its default
            value is 250.
        * <split-brain-protection-ref>:
            Adds the Split Brain Protection for this data-structure which you configure using the <split-brain-protection>
            element. You should set the <split-brain-protection-ref>'s value as the <split-brain-protection>'s name.
        * <priority-comparator-class-name>:
            Fully-qualified comparator's class name to be used for the priority queue.
            If nothing is provided, then queue behaves as a FIFO queue.

            If this value is non-null, then Hazelcast will ignore the queue store
            "memory-limit" configuration value.
    -->
    <queue name="default">
        <statistics-enabled>true</statistics-enabled>
        <max-size>0</max-size>
        <backup-count>1</backup-count>
        <async-backup-count>0</async-backup-count>
        <empty-queue-ttl>-1</empty-queue-ttl>
        <item-listeners>
            <item-listener include-value="true">com.hazelcast.examples.ItemListener</item-listener>
        </item-listeners>
        <queue-store>
            <class-name>com.hazelcast.QueueStoreImpl</class-name>
            <properties>
                <property name="binary">false</property>
                <property name="memory-limit">1000</property>
                <property name="bulk-load">500</property>
            </properties>
        </queue-store>
        <split-brain-protection-ref>splitBrainProtectionRuleWithThreeNodes</split-brain-protection-ref>
        <merge-policy batch-size="100">PutIfAbsentMergePolicy</merge-policy>
        <priority-comparator-class-name>com.hazelcast.collection.impl.queue.model.PriorityElementComparator</priority-comparator-class-name>
    </queue>

    <!--
        ===== HAZELCAST MAP CONFIGURATION =====

        Configuration element's name is <map>. It has the optional attribute "name" with which you
        can specify the name of your map. Its default value is "default".
        It has the following sub-elements:
        * <in-memory-format>:
        Specifies in which format data will be stored in your map. Available values are as follows:
        - BINARY:
            Data will be stored in serialized binary format. It is the default option.
        - OBJECT:
            Data will be stored in deserialized form.
        * <statistics-enabled>:
            When you enable it, you can have map level statistics such as last access time to map,
            total number of hits, key, value, etc. Its default value is true.
        * <per-entry-stats-enabled>:
            Enable/disable per entry statistics. Its default value is false.
            When you enable it, you can retrieve entry level statistics such as hits, creation time,
            last access time, last update time,last stored time.
        * "<eviction>":
           By default map has no eviction configured. Its <eviction-policy> is NONE.
           To make it work you have to configure it.
           Configuration has the following attributes:
           - size: Maximum size of the map.
           - max-size-policy: Maximum size policy for eviction of the map. Available values are as follows:
             * PER_NODE:
               Maximum number of map entries in each cluster member. You cannot set the max-size to a value lower
               than the partition count (which is 271 by default).
             * PER_PARTITION:
               Maximum number of map entries within each partition.
             * USED_HEAP_SIZE:
               Maximum used heap size in megabytes per map for each Hazelcast instance. It does not work when
               "in-memory-format" is set to OBJECT.
             * USED_HEAP_PERCENTAGE:
               Maximum used heap size percentage per map for each Hazelcast instance. If, for example, JVM is
               configured to have 1000 MB and this value is 10, then the map entries will be evicted when used heap size
               exceeds 100 MB. It does not work when "in-memory-format" is set to OBJECT.
             * FREE_HEAP_SIZE:
               Minimum free heap size in megabytes for each Hazelcast instance.
             * FREE_HEAP_PERCENTAGE:
               Minimum free heap size percentage for each Hazelcast instance. If, for example, JVM is configured to
               have 1000 MB and this value is 10, then the map entries will be evicted when free heap size is below 100 MB.
           - eviction-policy:
               Eviction policy has following values:
             * NONE: No eviction.
             * LRU: Least recently used entries will be removed.
             * LFU: Least frequently used entries will be removed.
             * RANDOM: Randomly selected entries will be removed.
        * <metadata-policy>
        Metadata policy for this map. Hazelcast may process objects of supported types ahead of time to
        create additional metadata about them. This metadata then is used to make querying and indexing faster.
        Metadata creation may decrease put throughput.
        Valid values are:
        CREATE_ON_UPDATE (default): Objects of supported types are pre-processed when they are created and updated.
        OFF: No metadata is created.
        * <cache-deserialized-values>:
        Controls caching of deserialized values. Caching makes the query evaluation faster, but it costs memory.
        Available values are as follows:
        - NEVER: Deserialized values will never be cached.
        - INDEX-ONLY: Deserialized values will be cached only when they are inserted into an index.
        - ALWAYS: Deserialized values will always be cached.
        * <backup-count>:
            Count of synchronous backups. When this count is 1, a map entry will have its backup on one other node in
            the cluster. If you set it to 2, then a map entry will have its backup on two other nodes. You can set it
            to 0 if you do not want your entries to be backed up. The maximum value for the backup count is 6.
            Its default value is 1.
        * <async-backup-count>:
        Number of asynchronous backups. Unlike the synchronous backup process, asynchronous backup process does not
        block the map operations. Its default value is 0, meaning there will be no asynchronous backups.
        * <time-to-live-seconds>:
        Maximum time in seconds for each entry to stay in the map. If it is not 0, entries that are older than
        this time and not updated for this time are evicted automatically. Valid values are integers between 0 and
        Integer.MAX VALUE. Its default value is 0, which means infinite. If it is not 0, entries are evicted regardless
        of the set eviction-policy.
        * <max-idle-seconds>:
        Maximum time in seconds for each entry to stay idle in the map. Entries that are idle for more than
        this time are evicted automatically. An entry is idle if no get, put, EntryProcessor.process or
        containsKey is called.  Valid values are integers between 0 and Integer.MAX VALUE. Its default value
        is 0, which means infinite.
        * <merge-policy>:
        Policy that specifies how the map entries in the small cluster will merge with the bigger cluster after a
        split-brain syndrome. Its default values is "com.hazelcast.spi.merge.PutIfAbsentMergePolicy". Available
        built-in policies are as follows:
        - com.hazelcast.spi.merge.PassThroughMergePolicy:
            Entry will be added if there is no existing entry for the key.
        - com.hazelcast.spi.merge.PutIfAbsentMergePolicy:
            Entry will be added if the merging entry does not exist in the cluster.
        - com.hazelcast.spi.merge.HigherHitsMergePolicy:
            Entry with the higher number of hits wins.
        - com.hazelcast.spi.merge.LatestUpdateMergePolicy:
            Entry with the latest update wins.
        * <read-backup-data>:
        Used to enable reading from local backup map entries. Its default value is false. It can be used if there is
        at least 1 sync or async backup.
        * <merkle-tree>:
        It has the following attributes and sub-elements:
        - enabled:
            Specifies whether the merkle tree is enabled.
        - <depth>:
            The depth of the merkle tree.
             A larger depth means that a data synchronization mechanism will be able
             to pinpoint a smaller subset of the data structure contents in which a
             change occurred. This causes the synchronization mechanism to be more
             efficient. On the other hand, a larger tree depth means the merkle tree
             will consume more memory.
             A smaller depth means the data synchronization mechanism will have to
             transfer larger chunks of the data structure in which a possible change
             happened. On the other hand, a shallower tree consumes less memory.
             The depth must be between 2 and 27 (exclusive). The default depth is 10.
        * <event-journal>:
        It has the following attributes and sub-elements:
        - enabled:
            Specifies whether the event journal is enabled.
        - <capacity>:
            The capacity of the event journal. The capacity is the total number of items that the event journal
            can hold at any moment. The actual number of items contained in the journal can be lower. Its default value is 10000.
            The capacity is shared equally between all partitions.
            This is done by assigning each partition {@code getCapacity() / partitionCount}
            available slots in the event journal. Because of this, the effective total
            capacity may be somewhat lower and you must take into account that the
            configured capacity is at least greater than the partition count.
        - <time-to-live-seconds>:
            Sets the time to live in seconds.
            Time to live is the time the event journal retains items before removing them from the journal.
            The events are removed on journal read and write actions, not while the journal is idle.
            Time to live can be disabled by setting timeToLiveSeconds to 0. This means that the
            events never expire but they can be overwritten when the capacity of the journal is exceeed.
            Any integer between 0 and Integer.MAX_VALUE. 0 means infinite. Its default value is 0.
        * <map-store>:
        Configuration options when you want to load/store the map entries from/to a persistent data store such as a
        relational database. Before configuring <map-store>, you need to implement Hazelcast's MapStore or MapLoader
        interfaces.
        It has the following attributes:
        - enabled:
            Set to true to enable the map store functionality for your map. Its default value is true.
        - initial-mode:
            Sets the initial entry loading mode. Available values are as follows:
             - LAZY: The loading is asynchronous. It is the default mode.
             - EAGER: The loading is blocked until all partitions are loaded.

        It has the following sub-elements:
        - <class-name>:
            The name of your class implementing MapLoader and/or MapStore interface.
        - <write-delay-seconds>:
            Number of seconds to delay the storing of entries. If the value is 0, then it is write-through.
            Otherwise, it is write-behind so updates will be stored after this period. Its default value is 0.
        - <write-batch-size>:
            Used to create batches when writing to map store. In default mode, all map entries will try
            to be written in one go. To create batches, the minimum meaningful value is 2. For values smaller than 2,
            it works as in default mode. Its default value is 1.
        - <write-coalescing>:
            It is meaningful if you are using write behind in MapStore. When it is set to true,
            only the latest store operation on a key during the write-delay-seconds will be
            reflected to MapStore. Its default value is true.
        - <properties>:
            While you are implementing MapStore or MapLoader you can define specific properties to be configured.
            It can be your store's URL, credentials, etc. Please see the example map configuration snippet below.
        * <near-cache>:
        Configuration options when you want to use a Near Cache for your map.
        It has the following attributes:
        - name: You can give a name for your Near Cache. It is optional and its default value is "default".

        It has the following sub-elements:
            - <time-to-live-seconds>:
                Maximum number of seconds for each entry to stay in the Near Cache. Entries that are older than this
                period are automatically evicted from the Near Cache. Any integer between 0 and Integer.MAX_VALUE.
                0 means infinite. Its default value is 0.
            - <max-idle-seconds>:
                Maximum number of seconds each entry can stay in the Near Cache as untouched (not read). Entries that
                are not read more than this period are removed from the Near Cache. Any integer between 0 and
                Integer.MAX_VALUE. 0 means Integer.MAX_VALUE. Its default value is 0.
            - <invalidate-on-change>:
                Specifies whether the cached entries are evicted when the entries are updated or removed. Its default
                value is true.
            - <in-memory-format>:
            Specifies in which format data will be stored in your Near Cache. Note that a map's in-memory format
            can be different from that of its Near Cache.
            Available values are as follows:
            - BINARY:
                Data will be stored in serialized binary format. It is the default option.
            - OBJECT:
                Data will be stored in deserialized form.
            - <cache-local-entries>:
                Specifies whether the local entries will be cached. It can be useful when in-memory format for
                Near Cache is different from that of the map. By default, it is disabled.
            - <eviction>:
                Configuration for the eviction. It has following attributes:
                - size: Maximum size (entry count) of the Near Cache.
                - max-size-policy: Maximum size policy for eviction of the Near Cache. Available values are as follows:
                    * ENTRY_COUNT: Maximum entry count per member.
                - eviction-policy: See the <eviction-policy> element above.
                - comparator-class-name: The comparator to be used while comparing entries to be evicted.
        * <wan-replication-ref>:
            Configuration of the WAN replication for your map.
            It has the following attributes:
            - name:
                Name of the WAN replication configuration specified in the "name" attribute of the
                <wan-replication> element. See the <wan-replication> element above.

            It has the following sub-elements:
            - <filters>:
                Filters to intercept WAN replication events before they are placed to WAN event replication
                queues by providing a filtering API. Just implement Hazelcast's MapWanEventFilter interface
                to create your filters. You can define multiple filters and add to the configuration using the
                <filter> sub-elements within the <filters> element.
            - <republishing-enabled>:
                When enabled, an incoming event to a member is forwarded to target cluster of that member. Its
                default value is true.
             - <merge-policy-class-name>:
                Resolve conflicts that occurred when target cluster already has the replicated
                entry key.

                4 merge policy implementations for IMap and 2 merge policy implementations for
                ICache are provided out-of-the-box.

                IMap has the following merge policies:
                com.hazelcast.spi.merge.PutIfAbsentMergePolicy: Incoming entry merges from the
                source map to the target map if it does not exist in the target map.
                com.hazelcast.spi.merge.HigherHitsMergePolicy: Incoming entry merges from the
                source map to the target map if the source entry has more hits than the target one.
                com.hazelcast.spi.merge.PassThroughMergePolicy: Incoming entry merges from the
                source map to the target map unless the incoming entry is not null.
                com.hazelcast.spi.merge.LatestUpdateMergePolicy: Incoming entry merges from the
                source map to the target map if the source entry has been updated more recently
                than the target entry. Please note that this merge policy can only be used when the
                clusters' clocks are in sync.

                ICache has the following merge policies:
                com.hazelcast.spi.merge.HigherHitsMergePolicy: Incoming entry merges from
                the source cache to the target cache if the source entry has more hits than the
                target one.
                com.hazelcast.spi.merge.PassThroughMergePolicy: Incoming entry merges from
                the source cache to the target cache unless the incoming entry is not null.

                The default policy is com.hazelcast.spi.merge.PassThroughMergePolicy.
        * <indexes>:
        You can define indexes for your map using this element's <index> sub-elements. Index definition consists
        of type, optional name and the list of columns to be indexed. Valid types are SORTED (default) and HASH.
        * <attributes>:
        You can define attributes that may be referenced in predicates, queries and indexes using this element's
        <attribute> sub-elements. Each <attribute> has only the "extractor-class-name" attribute which you should
        define beforehand by implementing Hazelcast's ValueExtractor class.
        * <entry-listeners>:
            Adds listeners (listener classes) for the map entries using the <entry-listener> sub-elements. You can also set its
            attribute "include-value" to true if you want the entry event to contain the item values, and you can set its attribute
            "local" to true if you want to listen to the entries on the local member.
        * <partition-lost-listeners>:
            Adds the partition lost listeners that you created by implementing Hazelcast's PartitionLostListener interface.
        * <split-brain-protection-ref>:
        Adds the split brain protection for this map which you configure using the <split-brain-protection> element.
        You should set the <split-brain-protection-ref>'s value
        as the <split-brain-protection>'s name.
     -->
    <map name="default">
        <in-memory-format>BINARY</in-memory-format>
        <metadata-policy>CREATE_ON_UPDATE</metadata-policy>
        <statistics-enabled>true</statistics-enabled>
        <per-entry-stats-enabled>false</per-entry-stats-enabled>
        <cache-deserialized-values>ALWAYS</cache-deserialized-values>
        <backup-count>1</backup-count>
        <async-backup-count>0</async-backup-count>
        <time-to-live-seconds>0</time-to-live-seconds>
        <max-idle-seconds>0</max-idle-seconds>
        <eviction eviction-policy="NONE" max-size-policy="PER_NODE" size="0"/>
        <merge-policy batch-size="100">PutIfAbsentMergePolicy</merge-policy>
        <read-backup-data>false</read-backup-data>
        <merkle-tree enabled="false">
            <depth>10</depth>
        </merkle-tree>
        <event-journal enabled="false">
            <capacity>10000</capacity>
            <time-to-live-seconds>0</time-to-live-seconds>
        </event-journal>
        <map-store enabled="true" initial-mode="LAZY">
            <class-name>com.hazelcast.examples.DummyStore</class-name>
            <write-delay-seconds>60</write-delay-seconds>
            <write-batch-size>1000</write-batch-size>
            <write-coalescing>true</write-coalescing>
            <properties>
                <property name="jdbc_url">my.jdbc.com</property>
            </properties>
        </map-store>
        <near-cache>
            <time-to-live-seconds>0</time-to-live-seconds>
            <max-idle-seconds>60</max-idle-seconds>
            <invalidate-on-change>true</invalidate-on-change>
            <in-memory-format>BINARY</in-memory-format>
            <cache-local-entries>false</cache-local-entries>
            <eviction size="1000" max-size-policy="ENTRY_COUNT" eviction-policy="LFU"/>
        </near-cache>
        <wan-replication-ref name="my-wan-cluster-batch">
            <merge-policy-class-name>PassThroughMergePolicy</merge-policy-class-name>
            <republishing-enabled>false</republishing-enabled>
        </wan-replication-ref>
        <indexes>
            <!-- unordered/hash index on the name attribute -->
            <index type="HASH">
                <attributes>
                    <attribute>name</attribute>
                </attributes>
            </index>
            <!-- ordered/tree index on the age attribute -->
            <index>
                <attributes>
                    <attribute>age</attribute>
                </attributes>
            </index>
            <!-- composite unordered/hash index on the name and age attributes -->
            <index type="HASH">
                <attributes>
                    <attribute>name</attribute>
                    <attribute>age</attribute>
                </attributes>
            </index>
            <!-- composite ordered/tree index on the age and name attributes -->
            <index>
                <attributes>
                    <attribute>age</attribute>
                    <attribute>name</attribute>
                </attributes>
            </index>
            <!-- bitmap index on the age attribute -->
            <index type="BITMAP">
                <attributes>
                    <attribute>age</attribute>
                </attributes>
            </index>
            <!-- bitmap index on the name attribute with options -->
            <index type="BITMAP">
                <attributes>
                    <attribute>name</attribute>
                </attributes>
                <bitmap-index-options>
                    <unique-key>id</unique-key>
                    <unique-key-transformation>RAW</unique-key-transformation>
                </bitmap-index-options>
            </index>
        </indexes>
        <attributes>
            <attribute extractor-class-name="com.bank.CurrencyExtractor">currency</attribute>
        </attributes>
        
        <!--
        ===== HAZELCAST CONTINUOUS QUERY CACHE CONFIGURATION =====

        Configuration element's name is <query-caches>.
        You can create your query caches using its  <query-cache> sub-element. Its parent element is <map>,
        i.e. it should be placed within the <map> configuration. Each <query-cache> has the attribute "name" with which you
        can specify the name of your query cache.
        It has the following sub-elements:
        * <include-value>:
            Set to true if you want to cache the value too. Its default value is true.
        * <predicate>:
            Predicate to filter events which will be applied to the query cache.
        * <entry-listeners>:
            Adds listeners (listener classes) for your query cache entries. See <entry-listeners> in the map configuration above.
        * <in-memory-format>:
            Type of the data to be stored in your query cache. See <in-memory-format> in the map configuration above.
        * <populate>:
            Set to true if you want to enable the initial population of your query cache. Its default value is true.
        * <coalesce>:
            Set to true if you want to enable the coalescing of your query cache. Its default value is false.
        * <delay-seconds>:
            Minimum time in seconds that an event waits in the member's buffer. Its default value is 0.
        * <batch-size>:
            Batch size used to determine the number of events sent in a batch to your query cache. Its default value is 1.
        * <buffer-size>:
            Maximum number of events which can be stored in a partition buffer. Its default value is 16.
        * <eviction>:
            Configuration for the eviction of your query cache. See <eviction> in the map configuration above.
        * <indexes>:
            You can define indexes for your query cache using this element's <index> sub-elements. See <index> in the
            map configuration above.
    -->
        <query-caches>
            <query-cache name="myContQueryCache">
                <include-value>true</include-value>
                <predicate type="class-name">com.hazelcast.examples.ExamplePredicate</predicate>
                <entry-listeners>
                    <entry-listener>...</entry-listener>
                </entry-listeners>
                <in-memory-format>BINARY</in-memory-format>
                <populate>true</populate>
                <coalesce>false</coalesce>
                <delay-seconds>3</delay-seconds>
                <batch-size>2</batch-size>
                <buffer-size>32</buffer-size>
                <eviction size="1000" max-size-policy="ENTRY_COUNT" eviction-policy="LFU"/>
                <indexes>
                    <index>
                        <attributes>
                            <attribute>name</attribute>
                        </attributes>
                    </index>
                </indexes>
            </query-cache>
        </query-caches>
    </map>

    <!--
        ===== HAZELCAST MULTIMAP CONFIGURATION =====

        Configuration element's name is <multimap>. It has the optional attribute "name" with which you
        can specify the name of your multimap. Its default value is "default".
        All sub-elements of <multimap> except <value-collection-type> and <binary> have the same meaning as in <map> configuration.
        You can specify the type of the value collection using <value-collection-type>. Available values are SET and LIST.
        By default, BINARY in-memory format is used, meaning that the object is stored in a serialized form.
        You can set the element <binary> to false, then, the OBJECT in-memory format is used.
        It has also the following sub-elements:
        * <split-brain-protection-ref>:
        Adds the Split Brain Protection for this data-structure which you configure using the <split-brain-protection>
        element. You should set the <split-brain-protection-ref>'s value as the <split-brain-protection>'s name.
    -->
    <multimap name="default">
        <backup-count>1</backup-count>
        <async-backup-count>0</async-backup-count>
        <binary>true</binary>
        <value-collection-type>SET</value-collection-type>
        <entry-listeners>
            <entry-listener include-value="true" local="true">com.hazelcast.examples.EntryListener</entry-listener>
        </entry-listeners>
        <merge-policy batch-size="100">PutIfAbsentMergePolicy</merge-policy>
    </multimap>

    <!--
        ===== HAZELCAST REPLICATED MAP CONFIGURATION =====

        Configuration element's name is <replicatedmap>. It has the required attribute "name" with which you
        can specify the name of your replicated map.
        It has the following sub-elements:
        * <in-memory-format>:
        Specifies in which format data will be stored in your replicated map.
        Available values are as follows:
        - BINARY:
            Data will be stored in serialized binary format. It is the default option.
        - OBJECT:
            Data will be stored in deserialized form.
        * <async-fillup>:
            Specifies whether the replicated map is available for reads before the initial
        replication is completed. Its default value is true. If false, no Exception will be
        thrown when the replicated map is not yet ready, but call is blocked until the initial
        replication is completed.
        * <statistics-enabled>:
        When you enable it, you can retrieve replicated map entry statistics such as creation time,
        expiration time, number of hits, key, value, etc. Its default value is true.
        * <entry-listeners>:
            Adds listeners (listener classes) for the replicated map entries using the <entry-listener> sub-elements.
            You can also set its attribute "include-value" to true if you want the entry event to contain the item values,
            and you can set its attribute "local" to true if you want to listen to the entries on the local member.
        * <split-brain-protection-ref>:
        Adds the Split Brain Protection for this data-structure which you configure using the <split-brain-protection>
        element. You should set the <split-brain-protection-ref>'s value as the <split-brain-protection>'s name.
    -->
    <replicatedmap name="replicatedMap1">
        <in-memory-format>BINARY</in-memory-format>
        <async-fillup>true</async-fillup>
        <statistics-enabled>true</statistics-enabled>
        <entry-listeners>
            <entry-listener include-value="true" local="true">com.hazelcast.examples.EntryListener</entry-listener>
        </entry-listeners>
        <merge-policy batch-size="100">LatestAccessMergePolicy</merge-policy>
    </replicatedmap>

    <!--
        ===== HAZELCAST CACHE CONFIGURATION =====

        Configuration element's name is <cache>. It has the required attribute "name" with which you
        can specify the name of your cache.
        It has the following sub-elements:
        * <key-type>:
        Type of the cache entries' keys. The fully qualified class name of the cache key type should be given
        using its "class-name" attribute.
        * <value-type>:
        Type of the cache entries' values. The fully qualified class name of the cache value type should be given
        using its "class-name" attribute.
        * <statistics-enabled>:
            When you enable it, you can retrieve cache entry statistics such as creation time, expiration time,
            number of hits, key, value, etc. Its default value is false.
        * <management-enabled>:
        If set to true, JMX beans are enabled and collected statistics are provided. It doesn't automatically
        enable statistics collection. Its default value is false.
        * <read-through>:
        If set to true, enables read-through behavior of the cache to an underlying configured
        javax.cache.integration.CacheLoader which is also known as lazy-loading. Its default value is false.
        * <write-through>:
        If set to true, enables write-through behavior of the cache to an underlying configured
        javax.cache.integration.CacheWriter which passes any changed value to the external backend resource. Its default
        value is false.
        * <cache-loader-factory>:
        Fully qualified class name of the javax.cache.configuration.Factory implementation providing a
        javax.cache.integration.CacheLoader instance to the cache. Provide this class name by using its "class-name"
        attribute.
        * <cache-loader>: Name of the cache loader class.
        * <cache-writer-factory>:
        Fully qualified class name of the javax.cache.configuration.Factory implementation providing a
        javax.cache.integration.CacheWriter instance to the cache. Provide this class name using its "class-name"
        attribute.
        * <cache-writer>: Name of the cache writer class.
        * <expiry-policy-factory>:
        Fully qualified class name of the javax.cache.configuration.Factory implementation providing a
        javax.cache.expiry.ExpiryPolicy instance to the cache. Provide this class name using its "class-name"
        attribute.
        * <cache-entry-listeners>:
        List of cache entry listeners given by its <cache-entry-listener> sub-element. Each <cache-entry-listener>
        has the following attributes:
        - old-value-required:
            If set to true, previously assigned values for the affected keys will be sent to the
            javax.cache.event.CacheEntryListener implementation. Setting this attribute to true creates additional
            traffic. Its default value is false.
        - synchronous:
            If set to true, the javax.cache.event.CacheEntryListener implementation will be called in a synchronous
            manner. Its default value is false.
        It has the following sub-elements:
        - cache-entry-listener-factory:
            Fully qualified class name of the javax.cache.configuration.Factory implementation providing a
            javax.cache.event.CacheEntryListener instance.
        - cache-entry-event-filter-factory:
            Fully qualified class name of the javax.cache.configuration.Factory implementation providing a
            javax.cache.event.CacheEntryEventFilter instance.
        * <in-memory-format>:
            Specifies in which format data will be stored in your cache. Available values are as follows:
        - BINARY:
            Data will be stored in serialized binary format. It is the default option.
        - OBJECT:
            Data will be stored in deserialized form.
        * <backup-count>:
        Number of synchronous backups. If it is 1, for example, then all entries of the cache are copied to
        one other instance as synchronous for fail-safety. Its default value is 1.
        * <async-backup-count>:
            Number of asynchronous backups. For example, if it is 1, then all entries of the cache are copied to
            one other instance as asynchronous for fail-safety. The sum of <backup-count> and <async-backup-count>
            cannot be larger than 6. Its default value is 0.
        * <eviction>:
        Configuration for the eviction of your cache. It has the following attributes:
        - size: Maximum size (entry count) of the cache.
        - max-size-policy: Maximum size policy for eviction of the cache. Available values are as follows:
            * ENTRY_COUNT: Maximum entry count per member.
        - eviction-policy: See the <eviction-policy> element above.
        * <wan-replication-ref>:
            Configuration of the WAN replication for your cache.
            It has the following attributes:
            - name:
                Name of the WAN replication configuration specified in the "name" attribute of the
                <wan-replication> element. See the <wan-replication> element above.

            It has the following sub-elements:
            - <filters>:
                Filters to intercept WAN replication events before they are placed to WAN event replication
                queues by providing a filtering API. Just implement Hazelcast's CacheWanEventFilter interface
                to create your filters. You can define multiple filters and add to the configuration using the
                <filter> sub-elements within the <filters> element.
            - <republishing-enabled>:
                When enabled, an incoming event to a member is forwarded to target cluster of that member. Its
                default value is true.
             - <merge-policy>:
                Resolve conflicts that occurred when target cluster already has the replicated
                entry key.

                4 merge policy implementations for IMap and 2 merge policy implementations for
                ICache are provided out-of-the-box.

                ICache has the following merge policies:
                com.hazelcast.spi.merge.HigherHitsMergePolicy: Incoming entry merges from
                the source cache to the target cache if the source entry has more hits than the
                target one.
                com.hazelcast.spi.merge.PassThroughMergePolicy: Incoming entry merges from
                the source cache to the target cache unless the incoming entry is not null.
        * <split-brain-protection-ref>:
            Adds the split brain protection for this cache which you configure using the <split-brain-protection>
            element. You should set the <split-brain-protection-ref>'s value as the <split-brain-protection>'s name.
        * <partition-lost-listeners>:
            Adds the partition lost listeners that you created by implementing Hazelcast's PartitionLostListener interface.
        * <merge-policy>:
            The following are the built-in merge policies for cache. You can either use their full class names or constant
            names (given in parentheses).
        - com.hazelcast.spi.merge.PassThroughMergePolicy (PASS_THROUGH)
        - com.hazelcast.spi.merge.PutIfAbsentMergePolicy (PUT_IF_ABSENT)
        - com.hazelcast.spi.merge.HigherHitsMergePolicy (HIGHER_HITS)
        - com.hazelcast.spi.merge.LatestAccessMergePolicy (LATEST_ACCESS)
        * <event-journal>:
        It has the following attributes and sub-elements:
        - enabled:
            Specifies whether the event journal is enabled.
        - <capacity>:
            The capacity of the event journal. The capacity is the total number of items that the event journal
            can hold at any moment. The actual number of items contained in the journal can be lower. Its default value is 10000.
            The capacity is shared equally between all partitions.
            This is done by assigning each partition {@code getCapacity() / partitionCount}
            available slots in the event journal. Because of this, the effective total
            capacity may be somewhat lower and you must take into account that the
            configured capacity is at least greater than the partition count.
        - <time-to-live-seconds>:
            Sets the time to live in seconds.
            Time to live is the time the event journal retains items before removing them from the journal.
            The events are removed on journal read and write actions, not while the journal is idle.
            Time to live can be disabled by setting timeToLiveSeconds to 0. This means that the
            events never expire but they can be overwritten when the capacity of the journal is exceeed.
            Any integer between 0 and Integer.MAX_VALUE. 0 means infinite. Its default value is 0.
        * <disable-per-entry-invalidation-events>:
        Disables invalidation events for each entry; but full-flush invalidation events are still enabled.
        Full-flush invalidation means the invalidation of events for all entries when clear is called.
        The default value is false.
    -->
    <cache name="default">
        <key-type class-name="java.lang.Object"/>
        <value-type class-name="java.lang.Object"/>
        <statistics-enabled>false</statistics-enabled>
        <management-enabled>false</management-enabled>
        <read-through>true</read-through>
        <write-through>true</write-through>
        <cache-loader-factory
                class-name="com.example.cache.MyCacheLoaderFactory"/>
        <cache-writer-factory
                class-name="com.example.cache.MyCacheWriterFactory"/>
        <expiry-policy-factory
                class-name="com.example.cache.MyExpirePolicyFactory"/>
        <cache-entry-listeners>
            <cache-entry-listener old-value-required="false" synchronous="false">
                <cache-entry-listener-factory
                        class-name="com.example.cache.MyEntryListenerFactory"/>
                <cache-entry-event-filter-factory
                        class-name="com.example.cache.MyEntryEventFilterFactory"/>
            </cache-entry-listener>
        </cache-entry-listeners>
        <in-memory-format>BINARY</in-memory-format>
        <backup-count>1</backup-count>
        <async-backup-count>0</async-backup-count>
        <eviction size="1000" max-size-policy="ENTRY_COUNT" eviction-policy="LFU"/>
        <wan-replication-ref name="my-wan-cluster-batch">
            <merge-policy-class-name>PassThroughMergePolicy</merge-policy-class-name>
            <republishing-enabled>true</republishing-enabled>
            <filters>
                <filter-impl>com.example.SampleFilter</filter-impl>
            </filters>
        </wan-replication-ref>
        <merge-policy batch-size="100">LatestAccessMergePolicy</merge-policy>
        <event-journal enabled="false">
            <capacity>10000</capacity>
            <time-to-live-seconds>0</time-to-live-seconds>
        </event-journal>
        <disable-per-entry-invalidation-events>true</disable-per-entry-invalidation-events>
    </cache>


    <!--
        ===== HAZELCAST LIST CONFIGURATION =====

        Configuration element's name is <list>. It has the optional attribute "name" with which you
        can specify the name of your list. This attribute's default value is "default".
        It has the following sub-elements:
        * <statistics-enabled>:
        When you enable it, you can retrieve list statistics. Its default value is true.
        * <max-size>:
        Maximum size of the list (item count). Its default value is 0, meaning Integer.MAX_VALUE.
        * <backup-count>:
        Number of synchronous backups. List is a non-partitioned data structure, so all entries of a
        List reside in one partition. If it is set to 1, there will be 1 backup of that List in another
        member in the cluster. When it is 2, 2 members will have the backup. Its default value is 1.
        * <async-backup-count>:
        Number of asynchronous backups. Its default value is 0.
        * <item-listeners>:
        Adds listeners (listener classes) for the List items using its sub-element <item-listener>. You can
        also set its attribute "include-value" to true if you want the item event to contain the item values.
        * <split-brain-protection-ref>:
        Adds the Split Brain Protection for this data-structure which you configure using the <split-brain-protection>
        element. You should set the <split-brain-protection-ref>'s value as the <split-brain-protection>'s name.
    -->
    <list name="default">
        <statistics-enabled>false</statistics-enabled>
        <max-size>0</max-size>
        <backup-count>1</backup-count>
        <async-backup-count>0</async-backup-count>
        <item-listeners>
            <item-listener include-value="true">com.hazelcast.examples.ItemListener</item-listener>
        </item-listeners>
        <merge-policy batch-size="100">PutIfAbsentMergePolicy</merge-policy>
    </list>

    <!--
        ===== HAZELCAST SET CONFIGURATION =====

        Configuration element's name is <set>. It has the optional attribute "name" with which you
        can specify the name of your set. This attribute's default value is "default".
        It has the following sub-elements:
        * <statistics-enabled>:
        When you enable it, you can retrieve set statistics. Its default value is true.
        * <max-size>:
        Maximum size of the set (item count). Its default value is 0, meaning Integer.MAX_VALUE.
        * <backup-count>:
        Number of synchronous backups. Set is a non-partitioned data structure, so all entries of a
        Set reside in one partition. If it is set to 1, there will be 1 backup of that Set in another
        member in the cluster. When it is 2, 2 members will have the backup. Its default value is 1.
        * <async-backup-count>:
        Number of asynchronous backups. Its default value is 0.
        * <item-listeners>:
        Adds listeners (listener classes) for the Set items using its sub-element <item-listener>. You can
        also set its attribute "include-value" to true if you want the item event to contain the item values.
        * <split-brain-protection-ref>:
        Adds the Split Brain Protection for this data-structure which you configure using the <split-brain-protection>
        element. You should set the <split-brain-protection-ref>'s value as the <split-brain-protection>'s name.
    -->
    <set name="default">
        <backup-count>1</backup-count>
        <async-backup-count>0</async-backup-count>
        <max-size>10</max-size>
        <item-listeners>
            <item-listener include-value="true">com.hazelcast.examples.ItemListener</item-listener>
        </item-listeners>
        <merge-policy batch-size="100">PutIfAbsentMergePolicy</merge-policy>
    </set>

    <!--
        ===== HAZELCAST TOPIC CONFIGURATION =====

        Configuration element's name is <topic>. It has the optional attribute "name" with which you
        can specify the name of your topic. This attribute's default value is "default".
        It has the following sub-elements:
        * <global-ordering-enabled>:
        When it is set to true, all cluster members that listen to a topic will receive the messages in the
        same order they were published by all members. This way, Hazelcast guarantees that all members will
        see the in the same order. Its default value is false.
        * <statistics-enabled>:
        When you enable it, you can retrieve topic statistics such as total number of published and
        received messages. Its default value is true.
        * <message-listeners>:
        Adds listeners (listener classes) for the Topic messages using its sub-element <message-listener>.
        * <multi-threading-enabled>:
        Default is `false`, meaning only one dedicated thread will handle topic messages.
            When multi-threading is enabled (true), all threads from event thread pool can be used for message handling.
    -->
    <topic name="default">
        <global-ordering-enabled>true</global-ordering-enabled>
        <statistics-enabled>true</statistics-enabled>
        <message-listeners>
            <message-listener>com.hazelcast.examples.MessageListener</message-listener>
        </message-listeners>
    </topic>
    <!--
        ===== HAZELCAST RELIABLE TOPIC CONFIGURATION =====

        Reliable Topic uses the same ITopic interface. The main difference is that it is backed up by
        Hazelcast Ringbuffer data structure. Reliable Topic messages are stored in the Ringbuffer
        Configuration element's name is <reliable-topic>. It has the optional attribute "name" with which you
        can specify the name of your Reliable Topic, which is the same name you give to your Ringbuffer.
        This attribute's default value is "default".
        It has the following sub-elements:
        * <statistics-enabled>:
            Enables or disables statistics for this reliable topic.
            Collects the creation time, total number of published and received
            messages for each member locally. Its default value is true.
        * <read-batch-size>:
            Sets the read batch size.
            The ReliableTopic tries to read a batch of messages from the ringbuffer.
            It will get at least one, but if there are more available, then it will
            try to get more to increase throughput. The maximum read batch size can
            be influenced using the read batch size.
            Apart from influencing the number of messages to retrieve, the
            readBatchSize also determines how many messages will be processed
            by the thread running the MessageListener before it returns back
            to the pool to look for other MessageListeners that need to be
            processed. The problem with returning to the pool and looking for new work
            is that interacting with an executor is quite expensive due to contention
            on the work-queue. The more work that can be done without retuning to the
            pool, the smaller the overhead.
            If the readBatchSize is 10 and there are 50 messages available,
            10 items are retrieved and processed consecutively before the thread goes
            back to the pool and helps out with the processing of other messages.
            If the readBatchSize is 10 and there are 2 items available,
            2 items are retrieved and processed consecutively.
            If the readBatchSize is an issue because a thread will be busy
            too long with processing a single MessageListener and it can't
            help out other MessageListeners, increase the size of the
            threadpool so the other MessageListeners don't need to wait for
            a thread, but can be processed in parallel.
        * <topic-overload-policy>:
            A policy to deal with an overloaded topic; so topic where there is no place to store new messages.
            This policy can only be used in combination with the
            com.hazelcast.core.HazelcastInstance#getReliableTopic(String).
            The reliable topic uses a com.hazelcast.ringbuffer.Ringbuffer to
            store the messages. A ringbuffer doesn't track where readers are, so
            it has no concept of a slow consumers. This provides many advantages like
            high performance reads, but it also gives the ability to the reader to
            re-read the same message multiple times in case of an error.
            A ringbuffer has a limited, fixed capacity. A fast producer may overwrite
            old messages that are still being read by a slow consumer. To prevent
            this, we may configure a time-to-live on the ringbuffer (see
            com.hazelcast.config.RingbufferConfig#setTimeToLiveSeconds(int).
            Once the time-to-live is configured, the TopicOverloadPolicy
            controls how the publisher is going to deal with the situation that a
            ringbuffer is full and the oldest item in the ringbuffer is not old
            enough to get overwritten.
            Keep in mind that this retention period (time-to-live) can keep messages
            from being overwritten, even though all readers might have already completed reading.
            Its default value is BLOCK. Available values are as follows:
            - DISCARD_OLDEST:
                Using this policy, a message that has not expired can be overwritten.
                No matter the retention period set, the overwrite will just overwrite
                the item.
                This can be a problem for slow consumers because they were promised a
                certain time window to process messages. But it will benefit producers
                and fast consumers since they are able to continue. This policy sacrifices
                the slow producer in favor of fast producers/consumers.
            - DISCARD_NEWEST:
                Message that was to be published is discarded.
            - BLOCK:
                The caller will wait until there is space in the Ringbuffer.
            - ERROR:
                The publish call fails immediately.
        * <message-listeners>:
            Adds listeners (listener classes) for the Reliable Topic messages using its sub-element <message-listener>.
    -->
    <reliable-topic name="default">
        <statistics-enabled>true</statistics-enabled>
        <topic-overload-policy>ERROR</topic-overload-policy>
        <read-batch-size>10</read-batch-size>
        <message-listeners>
            <message-listener>com.hazelcast.examples.MessageListener</message-listener>
        </message-listeners>
    </reliable-topic>

    <!--
        ===== HAZELCAST RINGBUFFER CONFIGURATION =====

        Configuration element's name is <ringbuffer>. It has the required attribute "name" with which you
        can specify the name of your Ringbuffer.
        It has the following sub-elements:
        * <capacity>:
            Number of items in the Ringbuffer. If no <time-to-live-seconds> is set,
            this value will always be equal to the capacity after the head completes
            the first loop around the ring. This is because no items are being
            expired. Its default value is 10000.
        * <time-to-live-seconds>:
            Sets the time to live in seconds which is the maximum number of seconds
            for each item to stay in the ringbuffer before being removed.
            Entries that are older than time-to-live-seconds are removed from the
            ringbuffer on the next ringbuffer operation (read or write).
            Time to live can be disabled by setting time-to-live-seconds to 0.
            It means that items won't get removed because they expire. They may only
            be overwritten.
            When time-to-live-seconds is disabled and after the tail does a full
            loop in the ring, the ringbuffer size will always be equal to the capacity.
            The time-to-live-seconds can be any integer between 0 and Integer#MAX_VALUE.
            0 means infinite. The default is 0.
        * <backup-count>:
            Number of synchronous backups. For example, if it is set to 1, then the Ringbuffer items
            are copied to one other member for fail-safety. Its default value is 1.
        * <async-backup-count>:
            Number of asynchronous backups. Its default value is 0.
        * <in-memory-format>:
            Sets the in-memory format.
            Setting the in-memory format controls the format of the stored item in the
            ringbuffer:
            - OBJECT: the item is stored in deserialized format (a regular object)
            - BINARY (default): the item is stored in serialized format (a binary blob)
            The object in-memory format is useful when:
            - the object stored in object format has a smaller footprint than in
            binary format
            - if there are readers using a filter. Since for every filter
            invocation, the object needs to be available in object format.
        * <ringbuffer-store>:
            Includes the Ringbuffer store factory class name and property configurations.
            The store format is the same as the in-memory-format for the Ringbuffer.
        * <split-brain-protection-ref>:
            Adds the Split Brain Protection for this data-structure which you configure
            using the <split-brain-protection> element. You should set the
            <split-brain-protection-ref>'s value as the <split-brain-protection>'s name.
    -->
    <ringbuffer name="default">
        <capacity>10000</capacity>
        <time-to-live-seconds>0</time-to-live-seconds>
        <backup-count>1</backup-count>
        <async-backup-count>0</async-backup-count>
        <in-memory-format>BINARY</in-memory-format>
        <ringbuffer-store>
            <class-name>com.hazelcast.RingbufferStoreImpl</class-name>
            <properties>
                <property name="prop1">prop1-value</property>
                <property name="prop2">prop2-value</property>
            </properties>
        </ringbuffer-store>
        <merge-policy>PutIfAbsentMergePolicy</merge-policy>
    </ringbuffer>

    <!--
        ===== HAZELCAST FLAKE ID GENERATOR CONFIGURATION =====
        Configuration element's name is <flake-id-generator>. It has the required attribute "name" with which you
        can specify the name of your Flake ID generator.
        It has the following sub-elements:

        * <prefetch-count>:
            Sets how many IDs are pre-fetched on the background when one call to
            FlakeIdGenerator.newId() is made. Value must be in the range 1..100,000, default
            is 100.

            This setting pertains only to newId() calls made on the member that configured it.

        * <prefetch-validity-millis>:
            Sets for how long the pre-fetched IDs can be used. If this time elapses, a new batch of IDs
            will be fetched. Time unit is milliseconds, default is 600,000 (10 minutes).

            The IDs contain timestamp component, which ensures rough global ordering of IDs. If an
            ID is assigned to an object that was created much later, it will be much out of order. If you
            don't care about ordering, set this value to 0.

            This setting pertains only to newId() calls made on the member that configured it.

        * <epoch-start>:
            Sets the offset of timestamp component. Time unit is milliseconds, default is 1514764800000
             (1.1.2018 0:00 UTC).

        * <node-id-offset>:
            Sets the offset that will be added to the node ID assigned to cluster member for this generator.
            Might be useful in A/B deployment scenarios where you have cluster A which you want to upgrade.
            You create cluster B and for some time both will generate IDs and you want to have them unique.
            In this case, configure node ID offset for generators on cluster B.

        * <bits-sequence>:
            Sets the bit-length of the sequence component, default is 6 bits.

        * <bits-node-id>:
            Sets the bit-length of node id component. Default value is 16 bits.

        * <allowed-future-millis>:
            Sets how far to the future is the generator allowed to go to generate IDs without blocking, default is 15 seconds.

        * <statistics-enabled>:
            When you enable it, you can retrieve the Flake ID generators statistics. Its default value is true.
    -->
    <flake-id-generator name="default">
        <prefetch-count>100</prefetch-count>
        <prefetch-validity-millis>600000</prefetch-validity-millis>
        <epoch-start>1514764800000</epoch-start>
        <node-id-offset>0</node-id-offset>
        <bits-sequence>6</bits-sequence>
        <bits-node-id>16</bits-node-id>
        <allowed-future-millis>15000</allowed-future-millis>
        <statistics-enabled>true</statistics-enabled>
    </flake-id-generator>
    
    <!--
        ===== HAZELCAST MEMBER ATTRIBUTE CONFIGURATION =====

        You can define member attributes for your Hazelcast members to tag your members according to your
        business logic requirements. Configuration element's name is <member-attributes>. You can list
        each member attribute using its <attribute> sub-element. For each <attribute>, you need to provide its
        name, type and value.
    -->
    <member-attributes>
        <attribute name="CPU_CORE_COUNT">4</attribute>
        <attribute name="CPU_CORE_FREQ">1033</attribute>
    </member-attributes>
    
    <!--
        ===== HAZELCAST LITE MEMBER CONFIGURATION =====

        Configuration element's name is <lite-member>. When you want to use a Hazelcast member as a lite member,
        set this element's "enabled" attribute to true in that member's XML configuration. Lite members do not store
        data and are used mainly to execute tasks and register listeners. They do not have partitions.
    -->
    <lite-member enabled="false"/>
    
    <!--
        ===== HAZELCAST USER CODE DEPLOYMENT CONFIGURATION =====

        Configuration element's name is <user-code-deployment>. It has the required attribute "enabled" to
        specify whether this feature will be enabled on your cluster.
        It has the following sub-elements:
        * <class-cache-mode>:
            Controls the local caching behavior for the classes loaded from the remote class repository.
            Available values are as follows:
            ETERNAL: Cache the loaded classes locally. This is the default value and suitable when you load long-living objects,
            such as domain objects stored in a map.
            OFF: Do not cache the loaded classes locally.
        * <provider-mode>:
            Controls how the classes are served to the other cluster members. Available values are as follows:
            LOCAL_AND_CACHED_CLASSES: Serve classes loaded from both local classpath and from other members.
            This is the default value.
            LOCAL_CLASSES_ONLY: Serve classes from the local classpath only. Classes loaded from other members
            will be used locally, but they are not served to other members.
            OFF: Never serve classes to other members.
        * <blacklist-prefixes>:
            Comma separated name prefixes of classes/packages to be prevented from dynamic class loading.
            For example, if you set it as "com.foo", remote loading of all classes from the "com.foo" package
            will be blacklisted, including the classes from all its sub-packages. If you set it as "com.foo.Class",
            then the "Class" and all classes having the "Class" as prefix in the "com.foo" package will be blacklisted.
        * <whitelist-prefixes>:
            Comma separated name prefixes of classes/packages only from which the classes will be loaded. It allows
            to quickly configure remote loading only for classes from selected packages. It can be used together
            with blacklisting. For example, you can whitelist the prefix "com.foo" and blacklist the prefix "com.foo.secret".
        * <provider-filter>:
            Filter to constraint members to be used for a class loading request when a class is not available
            locally. The value is in the format "HAS_ATTRIBUTE:foo". When it is set as "HAS_ATTRIBUTE:foo", the class
            loading request will only be sent to the members which have "foo" as a member attribute.
    -->
    <user-code-deployment enabled="true">
        <class-cache-mode>ETERNAL</class-cache-mode>
        <provider-mode>LOCAL_CLASSES_ONLY</provider-mode>
    </user-code-deployment>


    <!--
        ===== HAZELCAST CRDT REPLICATION CONFIGURATION =====

        Configures the replication mechanism for all CRDT implementations.
        The CRDT states are replicated in rounds (the period is configurable) and in each round the state is replicated
        up to the configured number of members.
        It has the following sub-elements:
        * <max-concurrent-replication-targets>:
            The maximum number of target members that we replicate the CRDT states to in one period. A higher count
            will lead to states being disseminated more rapidly at the expense of burst-like behaviour - one update
            to a CRDT will lead to a sudden burst in the number of replication messages in a short time interval.
        * <replication-period-millis>:
            The period between two replications of CRDT states in milliseconds. A lower value will increase the
            speed at which changes are disseminated to other cluster members at the expense of burst-like behaviour - less
            updates will be batched together in one replication message and one update to a CRDT may cause a sudden
            burst of replication messages in a short time interval. The value must be a positive non-null integer.
    -->
    <crdt-replication>
        <max-concurrent-replication-targets>1</max-concurrent-replication-targets>
        <replication-period-millis>1000</replication-period-millis>
    </crdt-replication>

    <!--
    ===== HAZELCAST PN COUNTER CONFIGURATION =====

    Configuration element's name is <pn-counter>. It has the optional attribute "name" with which you
    can specify the name of your PN counter. Its default value is "default".
    It has the following sub-elements:
    * <replica-count>:
       Number of replicas on which the CRDT state will be kept. The updates are replicated
       asynchronously between replicas.
       The number must be greater than 1 and up to 2147483647 (Integer.MAX_VALUE).
       The default value is 2147483647 (Integer.MAX_VALUE).
    * <split-brain-protection-ref>:
       Adds the Split Brain Protection for this data-structure which you configure using the
       <split-brain-protection> element. You should set the <split-brain-protection-ref>'s value as the
       <split-brain-protection>'s name.
    * <statistics-enabled>:
        When you enable it, you can retrieve the PN counter statistics. Its default value is true.
    -->
    <pn-counter name="default">
        <replica-count>2147483647</replica-count>
        <split-brain-protection-ref>splitBrainProtectionRuleWithThreeNodes</split-brain-protection-ref>
        <statistics-enabled>true</statistics-enabled>
    </pn-counter>

    <!--
        ===== HAZELCAST ADVANCED NETWORK CONFIGURATION =====

        The advanced network configuration provides fine-tuning capabilities for
        configuring network with the ability of defining separate server sockets for
        different protocols, such as for member-member and member-client
        communication. This configuration renders exclusive or relation with the
        generic <network> configuration element.

        The configuration element's name is <advanced-network>. It has the following attribute:
        * enabled:
           Indicates whether the advanced network configuration is enabled or not. Default is false.

        The <advanced-network> element has the following sub-elements:
        * <join>:
            This configuration lets you choose a discovery mechanism that Hazelcast will use to form a cluster.
            Hazelcast can find members by multicast, TCP/IP lists and by various discovery mechanisms provided by different cloud APIs.
            The following are the elements of <join>:
            - <multicast>:
                Set its "enabled" attribute to true for discovery by multicast. It has another attribute
                ("loopbackModeEnabled") which enables or disables the loopback mode in the multicast discovery
                mechanism.
                It has the following sub-elements to fine tune the multicast discovery.
                - <multicast-group>:
                    Specifies the multicast group IP address when you want to create clusters within
                    the same network. Its default value is 224.2.2.3.
                - <multicast-port>:
                    Specifies the multicast socket port that the Hazelcast member listens to and
                    sends discovery messages through. Its default value is 54327.
                - <multicast-time-to-live>:
                    Time-to-live value for multicast packets sent out to control the scope of multicasts.
                - <multicast-timeout-seconds>:
                    Only when the members are starting up, this timeout (in seconds) specifies the
                    period during which a member waits for a multicast response from another node.
                    For example, if you set it as 60 seconds, each node will wait for 60 seconds until a
                    leader node is selected. Its default value is 2 seconds.
                - <trusted-interfaces>:
                    Includes IP addresses of trusted members. When a node wants to join to the cluster,
                    its join request will be rejected if it is not a trusted member.
                    You can give an IP addresses range using the wildcard (*) on the last digit of
                    IP address (e.g. 192.168.1.* or 192.168.1.100-110).
            - <tcp-ip>:
                It has the following attributes.
                - "enabled":
                    Specifies whether the TCP/IP discovery is enabled or not. Default value is false.
                - "connection-timeout-seconds":
                    The maximum amount of time Hazelcast is going to try to connect to a well known member
                    before giving up. Setting it to a too low value could mean that a member is not able
                    to connect to a cluster. Setting it to a too high value means that member startup could
                    slow down because of longer timeouts (e.g. when a well known member is not up). Increasing
                    this value is recommended if you have many IPs listed and the members cannot properly
                    build up the cluster. Its default value is 5.

                It has the following sub-elements.
                - <required-member>:
                    IP address of the required member. Cluster will only be formed if the member with this
                    IP address is found.
                - <member>:
                    IP address(es) of one or more well known members. Once members are connected to these
                    well known ones, all member addresses will be communicated with each other. You can
                    also give comma separated IP addresses using the <members> element or list the members
                    with the <member> element under <member-list>.
                - <members>:
                    Comma separated IP addresses of one or more well known members.
                - <member-list>:
                    IP address(es) of one or more well known members listed with the <member> element.
                - <interface>:
                    IP address(es) of one or more well known members.
            - <aws>:
                Set its "enabled" attribute to true for discovery within Amazon EC2.
                Please refer to https://github.com/hazelcast/hazelcast-aws/#configuration for the configuration details.
            - <gcp>:
                Set its "enabled" attribute to true for discovery within the Google Cloud Platform.
                Please refer to https://github.com/hazelcast/hazelcast-gcp/#configuration for the configuration details.
            - <azure>:
                Set its "enabled" attribute to true for discovery within Microsoft Azure.
                Please refer to https://github.com/hazelcast/hazelcast-azure/#configuring-at-hazelcast-side for
                the configuration details.
            - <kubernetes>:
                Set its "enabled" attribute to true for discovery in the Kubernetes environment.
                Please refer to https://github.com/hazelcast/hazelcast-kubernetes#hazelcast-configuration for
                the configuration details.
            - <eureka>:
                Set its "enabled" attribute to true for discovery with using Eureka Service Registry.
                Please refer to https://github.com/hazelcast/hazelcast-eureka#hazelcast-configuration for
                the configuration details.
            - <discovery-strategies>:
                Set its "enabled" attribute to true for discovery in various cloud infrastructures. You also need to set the
                value of "hazelcast.discovery.enabled" property to true. See the description of the <properties> element
                to learn how to do this.
                You can define multiple discovery strategies using the <discovery-strategy> sub-element and its
                properties. Please refer to
                http://docs.hazelcast.org/docs/latest/manual/html-single/index.html#discovering-cluster-members
                to see the properties you can use.
                The following is an example for EC2 cloud.
                <discovery-strategies>
                    <discovery-strategy class="com.hazelcast.jclouds.JCloudsDiscoveryStrategy" enabled="true">
                    <properties>
                        <property name="provider">aws-ec2</property>
                        <property name="identity">AWS_IDENTITY</property>
                        <property name="credential">AWS_CREDENTIAL</property>
                    </properties>
                    </discovery-strategy>
                </discovery-strategies>
        * <member-address-provider>:
            IMPORTANT
            This configuration is not intended to provide addresses of other cluster members with
            which the Hazelcast instance will form a cluster. This is an SPI for advanced use in
            cases where the DefaultAddressPicker does not pick suitable addresses to bind to
            and publish to other cluster members. For instance, this could allow easier
            deployment in some cases when running on Docker, AWS or other cloud environments.
            That said, if you are just starting with Hazelcast, you will probably want to
            set the member addresses by using the tcp-ip or multicast configuration
            or adding a discovery strategy.
            Member address provider allows to plug in own strategy to customize:
               1. What address Hazelcast will bind to
               2. What address Hazelcast will advertise to other members on which they can bind to
            In most environments you don't need to customize this and the default strategy will work just
            fine. However in some cloud environments the default strategy does not make the right choice and the
            member address provider delegates the process of address picking to external code. It has on optional attribute:
            * enabled:
               Specifies whether the member address provider SPI is enabled or not. Its default value is false.
            It has the following sub-elements:
                - <class-name>:
                    The name of the class implementing the com.hazelcast.spi.MemberAddressProvider interface.
                - <properties>:
                    The properties that will be provided when constructing the provided MemberAddressProvider. Hazelcast will
                    first try instantiating the provided class by invoking a constructor accepting a single
                    java.util.Properties instance. In the case where there is no such constructor and there are also
                    no properties defined by this configuration, Hazelcast will exceptionally try to use the no-arg
                    constructor.
        * <failure-detector>:
            A failure detector is responsible to determine if a member in the cluster is unreachable or crashed.
            Please refer to https://docs.hazelcast.org/docs/latest/manual/html-single/index.html#failure-detector-configuration
            for the failure detectors implemented by Hazelcast.

            This element has the following sub-element:
            * <icmp>:
                ICMP can be used in addition to the other detectors. It operates at layer 3 and detects network
                and hardware issues more quickly.

                It has the following sub-elements:
                * <timeout-milliseconds>:
                    Timeout in Milliseconds before declaring a failed ping.
                * <fail-fast-on-startup>:
                    Cluster Member will fail to start if it is unable to action an ICMP ping command when ICMP is enabled.
                    Failure is usually due to OS level restrictions.
                * <interval-milliseconds>:
                    Time in milliseconds between each ICMP ping.
                * <max-attempts>:
                    Maximum number of consecutive failed attempts before declaring a member suspect.
                * <parallel-mode>:
                    Run ICMP detection in parallel with the Heartbeat failure detector.
                * <ttl>:
                    Maximum number of times the IP Datagram (ping) can be forwarded, in most cases
                    all Hazelcast cluster members would be within one network switch/router therefore
                    default of 0 is usually sufficient.

        * <member-server-socket-endpoint-config>:
            Configures the server socket used for the member-member communication.
        * <client-server-socket-endpoint-config>:
            Configures the server socket used for the member-client communication.
        * <wan-server-socket-endpoint-config>:
            Configures the server sockets used for the WAN replication's inbound WAN connections.
            Multiple WAN server sockets can be configured to allow configuring separate server sockets
            for each inbound WAN connection.

        * <memcache-server-socket-endpoint-config>:

            These four server socket elements have the same attribute and sub-elements.

            The server socket elements have the following attribute:
            - "name":
                Name of the endpoint configuration. Only relevant when defining WAN server sockets.

            The server socket elements have the following sub-elements:
            * <port>:
                The ports which Hazelcast will use to communicate between cluster members. Its default value is 5701.
                It has the following attributes.
                - port-count:
                    The default value is 100, meaning that Hazelcast will try to bind 100 ports.
                    If you set the value of port as 5701, as members join the cluster, Hazelcast tries to find
                    ports between 5701 and 5801. You can change the port count in cases like having large
                    instances on a single machine or you are willing to have only a few ports assigned.
                - auto-increment:
                    Default value is true. If port is set to 5701, Hazelcast will try to find free
                    ports between 5701 and 5801. Normally, you will not need to change this value, but it comes
                    in handy when needed. You may also want to choose to use only one port. In that case, you can
                    disable the auto-increment feature of port by setting its value as false.
            * <public-address>:
                Overrides the public address of a node. By default, a node selects its socket address
                as its public address. But behind a network address translation (NAT), two endpoints (nodes)
                may not be able to see/access each other. If both nodes set their public addresses to their
                defined addresses on NAT, then they can communicate with each other. In this case, their
                public addresses are not an address of a local network interface but a virtual address defined by
                NAT.
                This is optional to set and useful when you have a private cloud.
            * <reuse-address>:
                When you shutdown a cluster member, the server socket port will be in the TIME_WAIT
                state for the next couple of minutes. If you start the member right after shutting it down,
                you may not be able to bind it to the same port because it is in the TIME_WAIT state. If you
                set reuse-address to true, the TIME_WAIT state is ignored and you can bind the member to the
                same port again. Default value is false.
            * <outbound-ports>:
                By default, Hazelcast lets the system pick up an ephemeral port during socket bind operation.
                But security policies/firewalls may require to restrict outbound ports to be used by
                Hazelcast-enabled applications. To fulfill this requirement, you can configure Hazelcast to use
                only defined outbound ports.
                The <outbound-ports> has the <ports> sub-element to allow you to define outbound ports.
            * <interfaces>:
                Specifies which network interfaces Hazelcast should use. You need to set its "enabled" attribute
                to true to be able to use your defined interfaces. You can define multiple interfaces
                using its <interface> sub-element. By default, it is disabled.
            
            * <socket-options>:
                It has the following sub-elements:
                * <buffer-direct>:
                    Specifies whether direct or non-direct buffers should be allocated for the socket. The default value is false.
                * <tcp-no-delay>:
                    Specifies whether Nagle's algorithm should be disabled. The default value is true meaning that Nagle's
                    algorithm is disabled.
                * <keep-alive>:
                    Specifies whether TCP keep-alive should be enabled. The default value is true.
                * <connect-timeout-seconds>:
                    Specifies the TCP timeout in seconds. The default value is 0.
                * <send-buffer-size-kb>:
                    Specifies the size of the send buffer. The default value is 128KB.
                * <receive-buffer-size-kb>:
                    Specifies the size of the receive buffer. The default value is 128KB.
                * <linger-seconds>:
                    Specifies the TCP linger seconds. The default value is 0.

        * <rest-server-socket-endpoint-config>:
            Controls access to Hazelcast HTTP REST API.
            The methods available through REST API are grouped to several REST endpoint groups, which can be specified
            in this section.

            The <rest-server-socket-endpoint-config> element has the same attribute and sub-elements that the above server socket
            elements have plus it has the following additional sub-element.
            * <endpoint-groups>:
                Enables or disables named REST endpoint groups.
                If a group is not listed within the rest-api configuration, then it's 'enabledByDefault' flag is used
                to control the behavior of the group.

                The groups can be defined with the <endpoint-group> sub-element. Groups and their defaults:
                * CLUSTER_READ - enabled
                  Group of operations for retrieving cluster state and its version.
                * CLUSTER_WRITE - disabled
                  Operations which changes cluster or node state or their configurations.
                * HEALTH_CHECK - disabled
                  Group of endpoints for HTTP health checking.
                * HOT_RESTART - disabled
                  Group of HTTP REST APIs related to Hot Restart feature.
                * WAN - disabled
                  Group of HTTP REST APIs related to WAN Replication feature.
                * DATA - disabled
                  Group of HTTP REST APIs for data manipulation in the cluster (e.g. IMap and IQueue operations).

        * <wan-endpoint-config>:
            This element configures socket settings for the outgoing WAN connections.

            This element has "name" attribute and the following sub-elements from the list above:
            * <outbound-ports>
            * <interfaces>
            * <socket-options>

    -->
    <advanced-network enabled="false">
        <join>
            <multicast enabled="true" loopbackModeEnabled="true">
                <multicast-group>1.2.3.4</multicast-group>
                <multicast-port>12345</multicast-port>
                <multicast-timeout-seconds>5</multicast-timeout-seconds>
                <multicast-time-to-live>10</multicast-time-to-live>
                <trusted-interfaces>
                    <interface>10.10.1.*</interface>
                    <interface>10.10.2.*</interface>
                </trusted-interfaces>
            </multicast>
            <tcp-ip enabled="false" connection-timeout-seconds="123">
                <required-member>dummy</required-member>
                <member>dummy1</member>
                <member>dummy2</member>
                <interface>127.0.0.10</interface>
                <members>dummy3,dummy4</members>
                <member-list>
                    <member>dummy5</member>
                    <member>dummy6</member>
                </member-list>
            </tcp-ip>
            <aws enabled="false">
                <access-key>my-access-key</access-key>
                <secret-key>my-secret-key</secret-key>
                <region>us-west-1</region>
                <host-header>ec2.amazonaws.com</host-header>
                <connection-timeout-seconds>7</connection-timeout-seconds>
                <read-timeout-seconds>7</read-timeout-seconds>
                <connection-retries>4</connection-retries>
                <hz-port>5701-5710</hz-port>
                <tag-key>type</tag-key>
                <tag-value>hz-nodes</tag-value>
                <security-group-name>hazelcast-sg</security-group-name>
                <iam-role>dummy</iam-role>
                <use-public-ip>true</use-public-ip>
                <!--
                <cluster>my-cluster</cluster>
                <family>test-family</family>
                <service-name>test-service</service-name>
                -->
            </aws>
            <gcp enabled="false">
                <private-key-path>key-path</private-key-path>
                <projects>project-1,project-2</projects>
                <region>us-central1</region>
                <zones>us-central1-b,us-central1-c</zones>
                <label>key=value</label>
                <hz-port>5701-5710</hz-port>
                <use-public-ip>true</use-public-ip>
            </gcp>
            <azure enabled="false">
                <instance-metadata-available>false</instance-metadata-available>
                <client-id>CLIENT_ID</client-id>
                <client-secret>CLIENT_SECRET</client-secret>
                <tenant-id>TENANT_ID</tenant-id>
                <subscription-id>SUB_ID</subscription-id>
                <resource-group>RESOURCE-GROUP-NAME</resource-group>
                <scale-set>SCALE-SET-NAME</scale-set>
                <tag>TAG-NAME=HZLCAST001</tag>
                <hz-port>5701-5707</hz-port>
                <use-public-ip>true</use-public-ip>
            </azure>
            <kubernetes enabled="false">
                <namespace>MY-KUBERNETES-NAMESPACE</namespace>
                <service-name>MY-SERVICE-NAME</service-name>
                <service-label-name>MY-SERVICE-LABEL-NAME</service-label-name>
                <service-label-value>MY-SERVICE-LABEL-VALUE</service-label-value>
            </kubernetes>
            <eureka enabled="false">
                <self-registration>true</self-registration>
                <namespace>hazelcast</namespace>
            </eureka>
            <!--            <discovery-strategies>
                            <node-filter class="DummyFilterClass"/>
                            <discovery-strategy class="DummyClass" enabled="true">
                                <properties>
                                    <property name="foo">bar</property>
                                </properties>
                            </discovery-strategy>
                        </discovery-strategies>-->
        </join>
        <member-address-provider enabled="false">
            <class-name>DummyMemberAddressProvider</class-name>
            <properties>
                <property name="foo">bar</property>
            </properties>
        </member-address-provider>
        <failure-detector>
            <icmp enabled="false">
                <timeout-milliseconds>1000</timeout-milliseconds>
                <fail-fast-on-startup>true</fail-fast-on-startup>
                <interval-milliseconds>1000</interval-milliseconds>
                <max-attempts>2</max-attempts>
                <parallel-mode>true</parallel-mode>
                <ttl>255</ttl>
            </icmp>
        </failure-detector>
        <!-- cluster protocol server socket -->
        <member-server-socket-endpoint-config>
            <outbound-ports>
                <ports>33000-35000</ports>
                <ports>37000,37001,37002,37003</ports>
                <ports>38000,38500-38600</ports>
            </outbound-ports>
            <interfaces enabled="true">
                <interface>10.10.1.*</interface>
            </interfaces>
            
            
            <socket-options>
                <buffer-direct>true</buffer-direct>
                <tcp-no-delay>true</tcp-no-delay>
                <keep-alive>true</keep-alive>
                <connect-timeout-seconds>64</connect-timeout-seconds>
                <send-buffer-size-kb>25</send-buffer-size-kb>
                <receive-buffer-size-kb>33</receive-buffer-size-kb>
                <linger-seconds>99</linger-seconds>
            </socket-options>
            <port auto-increment="true" port-count="100">5701</port>
            <public-address>dummy</public-address>
            <!-- If the address should be reused. See NetworkConfig.setReuseAddress for more information. -->
            <reuse-address>true</reuse-address>
        </member-server-socket-endpoint-config>
        <!-- server socket listening for connections from hazelcast clients -->
        <client-server-socket-endpoint-config>
            <outbound-ports>
                <ports>38000,38500-38600</ports>
            </outbound-ports>
            <interfaces enabled="false">
                <interface>10.10.1.*</interface>
            </interfaces>
           
            
            <port auto-increment="true" port-count="100">9999</port>
            <public-address>10.10.0.10</public-address>
            <reuse-address>true</reuse-address>
        </client-server-socket-endpoint-config>
        <!-- create a server socket for REST API -->
        <rest-server-socket-endpoint-config name="internal-server-socket">
            <interfaces enabled="false">
                <interface>10.10.1.*</interface>
            </interfaces>
            <port auto-increment="false">8080</port>
            <public-address>192.168.1.10</public-address>
            <reuse-address>true</reuse-address>
            <endpoint-groups>
                <endpoint-group name="WAN" enabled="true"/>
                <endpoint-group name="CLUSTER_READ" enabled="true"/>
                <endpoint-group name="CLUSTER_WRITE" enabled="false"/>
                <endpoint-group name="HEALTH_CHECK" enabled="true"/>
            </endpoint-groups>
        </rest-server-socket-endpoint-config>

        <wan-server-socket-endpoint-config name="wan-server-socket-config">
            <interfaces enabled="false">
                <interface>192.168.8.101</interface>
                <interface>10.20.10.100</interface>
            </interfaces>
        </wan-server-socket-endpoint-config>
        <memcache-server-socket-endpoint-config name="memcache">
            <port auto-increment="false" port-count="10">6000</port>
        </memcache-server-socket-endpoint-config>
    </advanced-network>

    
    <!--
        ===== HAZELCAST METRICS CONFIGURATION =====

        Configuration element's name is <metrics>.

        It has the following attributes:
        - enabled:
            The master-switch for the metrics collection. If this is set
            to false no metrics collection is done, regardless of the other
            settings. Its default value is true.

        It has the following sub-elements:
        * <management-center>:
            Defines the Hazelcast Management Center related metrics configuration.

            It has the following attributes:
            * "enabled":
                Controls whether the metrics collected are exposed to
                Hazelcast Management Center. It is enabled by default.
                Please note that the metrics are polled by the
                Hazelcast Management Center, hence the members need to
                buffer the collected metrics between two polls. The aim
                for this switch is to reduce memory consumption of the
                metrics system if the Hazelcast Management Center is not
                used.

            It has the following  sub-elements:
            * <retention-seconds>:
                Sets the number of seconds the metrics will be retained on the
                instance. By default, metrics are retained for 5 seconds (that is for
                one collection of metrics values, if default <collection-frequency-seconds>
                collection frequency is used). More retention means more heap memory, but
                allows for longer client hiccups without losing a value (for example to
                restart the Management Center).

        * <jmx>:
            Defines the JMX related metrics configuration.

            It has the following attributes:
            * "enabled":
                Controls whether the metrics collected are exposed to
                through JMX. It is enabled by default.
                In order to expose the metrics, the metrics system need
                to be enabled via the enabled master-switch attribute.

        * <collection-frequency-seconds>:
            Sets the metrics collection frequency in seconds.
            By default, metrics are collected every 5 seconds.

    -->
    <metrics enabled="false">
        <management-center enabled="false">
            <retention-seconds>30</retention-seconds>
        </management-center>
        <jmx enabled="false"/>
        <collection-frequency-seconds>10</collection-frequency-seconds>
    </metrics>

    <auditlog enabled="false">
        <factory-class-name>com.acme.AuditlogToSyslogFactory</factory-class-name>
        <properties>
            <property name="host">syslogserver.acme.com</property>
            <property name="port">514</property>
            <property name="type">tcp</property>
        </properties>
    </auditlog>

    <!--
      ===== HAZELCAST INSTANCE TRACKING CONFIGURATION =====

      Configuration element's name is <instance-tracking>.

      It has the following attributes:
      - enabled:
          Enables or disables instance tracking.

      It has the following sub-elements:
      * <format-pattern>:
          Sets the pattern used to render the contents of the instance tracking file.
          It may contain placeholders for these properties:
          - "product": The instance product name, e.g. "Hazelcast".
          - "version": The instance version.
          - "mode": The instance mode which can be "server", "embedded" or "client".
          - "start_timestamp": The timestamp of when the instance was started expressed the difference,
          measured in milliseconds, between the current time and midnight, January 1, 1970 UTC
          - "licensed": If this instance is using a license or not. The value 0 signifies
          that there is no license set and the value 1 signifies that a license is in use.
          - "pid": Attempts to get the process ID value. The algorithm does not guarantee to get the
          process ID on all JVMs and operating systems so please test before use. In case we are unable to
          get the PID, the value will be -1.
          The placeholders are defined by a $HZ_INSTANCE_TRACKING{ prefix and followed by }.
          For instance, a placeholder for the "start_timestamp" would be $HZ_INSTANCE_TRACKING{start_timestamp}.
          The placeholders are resolved in a fail-safe manner. Any incorrect syntax
          is ignored and only the known properties are resolved, placeholders for
          any parameters which do not have defined values will be ignored. This also
          means that if there is a missing closing bracket in one of the placeholders,
          the property name will be resolved as anything from the opening bracket
          to the next closing bracket, which might contain additional opening brackets.
          If unset, a JSON formatted output will be used.
      * <file-name>:
          Sets the name of the file which will contain the tracking metadata. If left unset
          a file named "Hazelcast.process" will be created in the directory as returned by
          System.getProperty("java.io.tmpdir").
          The filename can contain placeholders that will be resolved in the same way
          as placeholders for the format pattern.

  -->
    <instance-tracking enabled="false">
        <file-name>hazelcast.process</file-name>
        <format-pattern>$HZ_INSTANCE_TRACKING{product}:$HZ_INSTANCE_TRACKING{version}</format-pattern>
    </instance-tracking>

    <!--
        ===== HAZELCAST SQL CONFIGURATION =====

        Configuration element's name is <sql>.

        It has the following sub-elements:
        * <executor-pool-sizer>:
            Defines the number of threads responsible for query execution.

        * <statement-timeout-millis>
            Defines the timeout in milliseconds that is applied to queries without an explicit timeout.

    -->
    <sql>
        <executor-pool-size>8</executor-pool-size>
        <statement-timeout-millis>0</statement-timeout-millis>
    </sql>

</hazelcast>
